// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use expect_test::expect;
use std::{
    collections::BTreeMap,
    fs::{self, File},
    io::{self, Read, Write},
    path::PathBuf,
};
use tempfile::TempDir;

use move_compiler::editions::{Edition, Flavor};
use move_package::lock_file::schema::write_packages;
use move_package::lock_file::schema::ToolchainVersion;
use move_package::lock_file::LockFile;
use move_package::resolution::dependency_graph::Package;
use move_package::source_package::parsed_manifest::DependencyKind::Local;
use move_package::BuildConfig;
use move_symbol_pool::Symbol;

#[test]
fn commit() {
    let pkg = create_test_package().unwrap();
    let lock_path = pkg.path().join("Move.lock");

    {
        let mut lock = LockFile::new(
            pkg.path().to_path_buf(),
            /* manifest_digest */ "42".to_string(),
            /* deps_digest */ "7".to_string(),
        )
        .unwrap();
        writeln!(lock, "# Write and commit").unwrap();
        lock.commit(&lock_path).unwrap();
    }

    assert!(lock_path.is_file());

    let lock_contents = {
        let mut lock_file = File::open(lock_path).unwrap();
        let mut buf = String::new();
        lock_file.read_to_string(&mut buf).unwrap();
        buf
    };

    // Check that the content written into the `LockFile` instance above can be found at the path
    // that that lock file was committed to (indicating that the commit actually happened).
    assert!(
        lock_contents.ends_with("# Write and commit\n"),
        "Lock file doesn't have expected content:\n{}",
        lock_contents,
    );
}

#[test]
fn discard() {
    let pkg = create_test_package().unwrap();

    {
        let mut lock = LockFile::new(
            pkg.path().to_path_buf(),
            /* manifest_digest */ "42".to_string(),
            /* deps_digest */ "7".to_string(),
        )
        .unwrap();
        writeln!(lock, "# Write but don't commit").unwrap();
    }

    assert!(!pkg.path().join("Move.lock").is_file());
}

#[test]
fn update_lock_file_toolchain_version() {
    let pkg = create_test_package().unwrap();
    let lock_path = pkg.path().join("Move.lock");

    let lock = LockFile::new(
        pkg.path().to_path_buf(),
        /* manifest_digest */ "42".to_string(),
        /* deps_digest */ "7".to_string(),
    )
    .unwrap();
    lock.commit(&lock_path).unwrap();

    let build_config = BuildConfig {
        default_flavor: Some(Flavor::Sui),
        default_edition: Some(Edition::E2024_ALPHA),
        lock_file: Some(lock_path.clone()),
        ..Default::default()
    };
    let _ =
        build_config.update_lock_file_toolchain_version(&pkg.path().to_path_buf(), "0.0.1".into());

    let mut lock_file = File::open(lock_path).unwrap();
    let toolchain_version =
        ToolchainVersion::read(&mut lock_file).expect("Invalid toolchain version");
    let toml =
        toml::ser::to_string(&toolchain_version).expect("Unable to serialize toolchain version");

    let expected = expect![[r#"
        compiler-version = "0.0.1"
        edition = "2024.alpha"
        flavor = "sui"
    "#]];
    expected.assert_eq(&toml);
}

#[test]
fn test_write_packages() {
    let pkg = create_test_package().unwrap();
    let lock_path = pkg.path().join("Move.lock");

    // Initialize lock file.
    let lock = LockFile::new(
        pkg.path().to_path_buf(),
        /* manifest_digest */ "42".to_string(),
        /* deps_digest */ "7".to_string(),
    )
    .unwrap();
    lock.commit(&lock_path).unwrap();

    // Write packages to lock file.
    let pb = PathBuf::from(pkg.path());
    let mut lock = LockFile::from(pb, &lock_path).unwrap();
    let mut packages = BTreeMap::new();
    let k = Symbol::from("x");
    let pp = PathBuf::from("test");
    let v = Package {
        kind: Local(pp),
        version: Some("v".into()),
        resolver: None,
    };
    packages.insert(k, v);
    write_packages(&mut lock, packages).unwrap();
    lock.commit(&lock_path).unwrap();

    // Read lock file and check contents.
    let mut lock_file = File::open(lock_path).unwrap();
    let contents = {
        let mut buf = String::new();
        let _ = lock_file.read_to_string(&mut buf);
        buf
    };

    let expected = expect![[r##"
        # @generated by Move, please check-in and do not edit manually.

        [move]
        version = 0
        manifest_digest = "42"
        deps_digest = "7"
    "##]];
    expected.assert_eq(&contents);
}

/// Create a simple Move package with no sources (just a manifest and an output directory) in a
/// temporary directory, and return it.
fn create_test_package() -> io::Result<TempDir> {
    let dir = tempfile::tempdir()?;

    let toml_path: PathBuf = [".", "tests", "test_sources", "basic_no_deps", "Move.toml"]
        .into_iter()
        .collect();

    fs::copy(toml_path, dir.path().join("Move.toml"))?;
    Ok(dir)
}
